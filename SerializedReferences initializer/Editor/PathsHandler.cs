using System;
using System.IO;
using UnityEditor.Compilation;
using UnityEngine;

namespace EditorTools.SerializedReferenceInitializer.Editor
{
    internal static class PathsHandler
    {
        private const string GeneratedClassesDirectoryName = "auto_generated";

        public static string GetScriptFilePath(Type type, string scriptName)
        {
            string scriptFileParentDirectoryPath = GetScriptFileParentDirectoryPath(type);
            if (string.IsNullOrEmpty(scriptFileParentDirectoryPath))
                return string.Empty;
            return Path.Combine(scriptFileParentDirectoryPath, scriptName);
        }

        public static string GetWrapperScriptFilePath(string wrappedClassParentDirectoryPath, string wrapperClassName)
        {
            return Path.Combine(wrappedClassParentDirectoryPath, GeneratedClassesDirectoryName,
                $"{wrapperClassName}.cs");
        }

        public static void CreateAutoGeneratedFilesDirectory(string wrapperScriptFilePath)
        {
            DirectoryInfo directoryInfo = Directory.GetParent(wrapperScriptFilePath)!;
            directoryInfo.Create();
        }

        public static string GetScriptFileParentDirectoryPath(Type type)
        {
            string assemblyName = type.Assembly.GetName().Name;
            // Find the assembly definition to which this file belongs to.
            string assemblyDefinitionFilePath =
                CompilationPipeline.GetAssemblyDefinitionFilePathFromAssemblyName(assemblyName);

            // Unity's default assembly (Assembly-CSharp) doesn't have an assembly definition file, so the path is null.
            if (string.IsNullOrEmpty(assemblyDefinitionFilePath))
            {
                string scriptFileInProjectFolder = FindScriptFileInProjectFolder(type.Name);
                return string.IsNullOrEmpty(scriptFileInProjectFolder)
                    ? string.Empty
                    : Directory.GetParent(scriptFileInProjectFolder).FullName;
            }

            // Assume that the namespace corresponds to the script's path.
            DirectoryInfo parentDirectory = Directory.GetParent(assemblyDefinitionFilePath)!;
            string scriptNamespace = type.Namespace!;
            int index = scriptNamespace.IndexOf($".{parentDirectory.Name}.", StringComparison.Ordinal);

            // The namespace doesn't corresponds to the script's path, so fall back to simple file search.
            if (index == -1)
            {
                string scriptFileInProjectFolder = FindScriptFileInProjectFolder(type.Name, assemblyName);
                return string.IsNullOrEmpty(scriptFileInProjectFolder)
                    ? string.Empty
                    : Directory.GetParent(scriptFileInProjectFolder).FullName;
            }

            // Concatenate the namespace parts to a valid relative-path
            string relativeNamespacePath = scriptNamespace.Substring(index + $".{parentDirectory.Name}.".Length)
                .Replace('.', Path.DirectorySeparatorChar);
            // Connect it to the assembly definition parent directory's path.
            string fullNamespacePath = Path.Combine(parentDirectory.FullName, relativeNamespacePath);
            return Directory.Exists(fullNamespacePath) ? fullNamespacePath : string.Empty;
        }

        public static string AbsolutePathToProjectRelativePath(string absolutePath)
        {
            return $"Assets{absolutePath.Substring(Application.dataPath.Length)}";
        }

        public static string ProjectRelativePathToAbsolutePath(string projectRelativePath)
        {
            string projectPathAfterAssets = projectRelativePath.Substring("Assets/".Length);
            return Path.Combine(Application.dataPath, projectPathAfterAssets);
        }

        private static string FindScriptFileInProjectFolder(string scriptName, string assemblyName = null) =>
            FindScriptFileIn(Application.dataPath, scriptName, assemblyName);

        private static string FindScriptFileIn(string folderPath, string scriptName, string assemblyName = null)
        {
            // Find all the files with the script's name.
            var files = Directory.GetFiles(folderPath, $"{scriptName}.cs",
                SearchOption.AllDirectories);

            if (files.Length == 1)
                return files[0];

            // There might be other script files with the same name in a different assembly,
            // so try to find which of the files belongs to the same assembly.
            foreach (string file in files)
            {
                string assemblyNameFromScriptPath = CompilationPipeline.GetAssemblyNameFromScriptPath(file);
                if (assemblyNameFromScriptPath.Equals(assemblyName, StringComparison.Ordinal))
                    return file;
            }

            return string.Empty;
        }
    }
}