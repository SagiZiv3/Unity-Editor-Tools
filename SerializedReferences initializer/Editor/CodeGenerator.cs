using System;
using System.CodeDom;
using System.CodeDom.Compiler;
using System.IO;
using System.Linq;
using System.Reflection;
using EditorTools.SerializedReferenceInitializer.Attributes;
using UnityEditor;
using UnityEngine;
using Object = UnityEngine.Object;

namespace EditorTools.SerializedReferenceInitializer.Editor
{
    internal static class CodeGenerator
    {
        private static string WrappedInstanceVariableName => "_instance";

        public static void GenerateWrapperClasses()
        {
            var types = TypeCache.GetTypesWithAttribute<GenerateWrapperForAttribute>();
            foreach (var type in types)
            {
                if (!type.IsSubclassOf(typeof(Object)))
                {
                    Debug.LogError($"Unsupported wrapped type: {type.FullName}!");
                    continue;
                }

                GenerateWrapperClass(type);
            }
        }

        private static void GenerateWrapperClass(Type classType)
        {
            var attribute = classType.GetCustomAttribute<GenerateWrapperForAttribute>();
            Type interfaceType = attribute.BaseType;
            // Make sure that the class implements the specified interface.
            if (!interfaceType.IsAssignableFrom(classType))
            {
                Debug.LogError($"{classType.FullName} must implement {interfaceType.FullName}");
                return;
            }

            string wrapperClassName = GetWrapperClassName(classType, interfaceType);
            string scriptParentDirectoryPath = PathsHandler.GetScriptFileParentDirectoryPath(classType);
            string wrapperScriptFilePath =
                PathsHandler.GetWrapperScriptFilePath(scriptParentDirectoryPath, wrapperClassName);

            // If the wrapper-class file exists, it means the wrapped interface wasn't modified.
            if (File.Exists(wrapperScriptFilePath))
            {
                return;
            }

            PathsHandler.CreateAutoGeneratedFilesDirectory(wrapperScriptFilePath);


            // Generate the namespace for the wrapper class
            var nameSpace = new CodeNamespace(classType.Namespace);
            nameSpace.Imports.Add(new CodeNamespaceImport("UnityEngine"));
            nameSpace.Imports.Add(new CodeNamespaceImport("System"));
            nameSpace.Imports.Add(new CodeNamespaceImport(typeof(AutoGeneratedWrapperAttribute).Namespace));

            var wrapperClass = new CodeTypeDeclaration(wrapperClassName)
            {
                IsClass = true,
                IsPartial = false,
                TypeAttributes = TypeAttributes.NotPublic | TypeAttributes.Serializable | TypeAttributes.Sealed,
                BaseTypes = { interfaceType },
                CustomAttributes =
                {
                    new CodeAttributeDeclaration(nameof(SerializableAttribute)),
                    new CodeAttributeDeclaration(
                        nameof(AutoGeneratedWrapperAttribute),
                        new CodeAttributeArgument(new CodeTypeOfExpression(classType))
                    )
                }
            };
            nameSpace.Types.Add(wrapperClass);

            // Add the instance variable to the wrapper class
            var instanceField = new CodeMemberField
            {
                Name = WrappedInstanceVariableName,
                Type = new CodeTypeReference(classType.FullName),
                Attributes = MemberAttributes.Private,
                CustomAttributes = { new CodeAttributeDeclaration(nameof(SerializeField)) },
            };
            wrapperClass.Members.Add(instanceField);

            // Add the interface methods to the wrapper class, and delegate them to the instance variable in the wrapper class
            var methods = interfaceType.GetMethods(BindingFlags.Public | BindingFlags.Instance);
            foreach (var method in methods)
            {
                AddDelegateMethod(method, wrapperClass);
            }

            // Add the interface properties to the wrapper class, and delegate them to the instance variable in the wrapper class
            var properties = interfaceType.GetProperties(BindingFlags.Public | BindingFlags.Instance);
            foreach (var property in properties)
            {
                AddDelegateProperty(property, wrapperClass);
            }

            AddClassConstructor(classType, wrapperClass);

            GenerateCodeFile(wrapperScriptFilePath, nameSpace);
        }

        private static void GenerateCodeFile(string wrapperScriptFilePath, CodeNamespace nameSpace)
        {
            // Add the classes to a CodeDomProvider and generate the source code
            var provider = CodeDomProvider.CreateProvider("CSharp");
            var options = new CodeGeneratorOptions
            {
                BracingStyle = "C"
            };

            using (var sourceWriter = new StreamWriter(wrapperScriptFilePath))
                provider.GenerateCodeFromNamespace(nameSpace, sourceWriter, options);

            // Make the file readonly so the user wouldn't accidentally modify it.
            File.SetAttributes(wrapperScriptFilePath, FileAttributes.ReadOnly);
        }

        private static void AddDelegateMethod(MethodInfo method, CodeTypeDeclaration wrapperClass)
        {
            // If this is a special method like a property's getter, skip it.
            if (method.IsSpecialName) return;
            var parameters = method.GetParameters();
            // Add the delegate method to the wrapper class
            var delegateMethod = new CodeMemberMethod
            {
                Name = method.Name,
                Attributes = MemberAttributes.Final | MemberAttributes.Public,
                ReturnType = new CodeTypeReference(method.ReturnType),
            };

            foreach (var parameter in parameters)
            {
                delegateMethod.Parameters.Add(
                    new CodeParameterDeclarationExpression(parameter.ParameterType, parameter.Name));
            }

            var invokeStatement = new CodeMethodInvokeExpression(
                new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), WrappedInstanceVariableName),
                method.Name,
                parameters.Select(p => new CodeVariableReferenceExpression(p.Name)).ToArray()
            );
            if (method.ReturnType != typeof(void))
            {
                delegateMethod.Statements.Add(new CodeMethodReturnStatement(invokeStatement));
            }
            else
            {
                delegateMethod.Statements.Add(invokeStatement);
            }

            wrapperClass.Members.Add(delegateMethod);
        }

        private static void AddDelegateProperty(PropertyInfo property, CodeTypeDeclaration wrapperClass)
        {
            // Add the delegate property to the wrapper class
            var delegateProperty = new CodeMemberProperty
            {
                Name = property.Name,
                Attributes = MemberAttributes.Final | MemberAttributes.Public,
                Type = new CodeTypeReference(property.PropertyType)
            };

            // Add the getter if exists
            if (property.CanRead)
                delegateProperty.GetStatements.Add(new CodeMethodReturnStatement(
                    new CodeFieldReferenceExpression(new CodeThisReferenceExpression(),
                        $"{WrappedInstanceVariableName}.{property.Name}")
                ));
            // Add the setter if exists
            if (property.CanWrite)
                delegateProperty.SetStatements.Add(new CodeAssignStatement(
                    new CodeFieldReferenceExpression(new CodeThisReferenceExpression(),
                        $"{WrappedInstanceVariableName}.{property.Name}"),
                    new CodePropertySetValueReferenceExpression()
                ));
            // Add the property to the type declaration
            wrapperClass.Members.Add(delegateProperty);
        }

        private static void AddClassConstructor(Type classType, CodeTypeDeclaration wrapperClass)
        {
            var constructor = new CodeConstructor
            {
                Attributes = MemberAttributes.Private
            };

            constructor.Parameters.Add(new CodeParameterDeclarationExpression(classType, "instance"));
            constructor.Statements.Add(new CodeAssignStatement(
                new CodeFieldReferenceExpression(new CodeThisReferenceExpression(), WrappedInstanceVariableName),
                new CodeArgumentReferenceExpression("instance"))
            );
            wrapperClass.Members.Add(constructor);
        }

        private static string GetWrapperClassName(Type wrappedClassType, Type interfaceType)
        {
            return $"{wrappedClassType.Name}_{interfaceType.Name}_Wrapper";
        }
    }
}